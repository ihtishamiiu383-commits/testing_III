# -*- coding: utf-8 -*-
"""testing_III.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1r9b5qD4S4WGWbncHoGPlK4AfoRlM-oWR
"""

import streamlit as st
import pandas as pd
import numpy as np
import random, re, ssl, smtplib
from datetime import datetime
from sklearn.compose import ColumnTransformer
from sklearn.preprocessing import OneHotEncoder
from sklearn.pipeline import Pipeline
from sklearn.ensemble import RandomForestClassifier
from transformers import pipeline as hf_pipeline

st.set_page_config(page_title="Predictive Buyer System", layout="wide")
COMPANY_NAME = "Crystal Gemstone"

# ---------- Helpers ----------
def is_valid_email(x):
    if pd.isna(x) or x == "Unknown": return False
    return re.match(r"^[^@\s]+@[^@\s]+\.[^@\s]+$", str(x)) is not None

def remove_outliers_iqr(df, col):
    q1, q3 = df[col].quantile([0.25, 0.75])
    iqr = q3 - q1
    return df.assign(**{col: df[col].clip(q1-1.5*iqr, q3+1.5*iqr)})

@st.cache_resource
def load_llm():
    try: return hf_pipeline("text-generation", model="distilgpt2")
    except: return None

text_generator = load_llm()

def send_email(sender, pwd, to, subject, body):
    try:
        with smtplib.SMTP_SSL("smtp.gmail.com", 465, context=ssl.create_default_context()) as s:
            s.login(sender, pwd)
            s.sendmail(sender, to, f"Subject:{subject}\n\n{body}".encode())
        return "Email sent successfully"
    except Exception as e:
        return str(e)

# ---------- UI ----------
st.title("ðŸ’Ž Predictive Buyer System with LLM Email Utility")
file = st.file_uploader("Upload Excel dataset", type="xlsx")
if not file: st.stop()

# ---------- Data Load & Clean ----------
df = pd.read_excel(file)
for c in df.select_dtypes("object"):
    df[c] = df[c].astype(str).str.strip().replace({"":np.nan,"nan":np.nan})

df = df.dropna(subset=["CustomerID","Gemstone Type","DateOfPurchase"])
df["DateOfPurchase"] = pd.to_datetime(df["DateOfPurchase"], errors="coerce")
df = df[df["DateOfPurchase"] <= pd.to_datetime(datetime.today())]
df = df.dropna(subset=["DateOfPurchase"])
for c in ["Price","Weight"]:
    if c in df.columns: df = remove_outliers_iqr(df,c)

df_cleaned = df.drop_duplicates()

# ---------- Customer Features ----------
freq = df_cleaned.groupby("CustomerID").size()
mon = df_cleaned.groupby("CustomerID")["Price"].sum()
avgp = df_cleaned.groupby("CustomerID")["Price"].mean()
avgw = df_cleaned.groupby("CustomerID")["Weight"].mean()
rec = (df_cleaned["DateOfPurchase"].max()
       - df_cleaned.groupby("CustomerID")["DateOfPurchase"].max()).dt.days

def mode(x): return x.mode().iloc[0] if not x.mode().empty else "Unknown"

cust_df = pd.DataFrame({
    "CustomerID": freq.index,
    "Frequency": freq.values,
    "TotalSpend": mon.values,
    "AvgPrice": avgp.values,
    "AvgWeight": avgw.values,
    "Recency": rec.values,
    "PrefType": df_cleaned.groupby("CustomerID")["Gemstone Type"].apply(mode).values
})

# ---------- Training Data ----------
rows=[]
items=df_cleaned[["Gemstone Type","Gemstone Color","Gemstone Origin","Certification","Weight","Price"]].drop_duplicates()
for cid,g in df_cleaned.groupby("CustomerID"):
    bought=set(tuple(x) for x in g[["Gemstone Type","Gemstone Color","Gemstone Origin","Certification"]].values)
    for _,r in g.iterrows():
        rows.append({"CustomerID":cid,"Type":r["Gemstone Type"],"Color":r["Gemstone Color"],
                     "Origin":r["Gemstone Origin"],"Cert":r["Certification"],
                     "Weight":r["Weight"],"Price":r["Price"],"Label":1})
    for _ in range(3):
        it=items.sample(1).iloc[0]
        if tuple(it[:4]) not in bought:
            rows.append({"CustomerID":cid,"Type":it[0],"Color":it[1],
                         "Origin":it[2],"Cert":it[3],
                         "Weight":it[4],"Price":it[5],"Label":0})

train=pd.DataFrame(rows).merge(cust_df,on="CustomerID")
X=train.drop("Label",axis=1); y=train["Label"]

pre=ColumnTransformer([
    ("cat",OneHotEncoder(handle_unknown="ignore"),["Type","Color","Origin","Cert","PrefType"]),
    ("num","passthrough",["Weight","Price","Frequency","TotalSpend","AvgPrice","AvgWeight","Recency"])
])

clf=Pipeline([("pre",pre),("rf",RandomForestClassifier(n_estimators=200,random_state=42))])
clf.fit(X,y)

# ---------- Prediction ----------
st.subheader("ðŸ”® New Gemstone")
gtype=st.selectbox("Type",df_cleaned["Gemstone Type"].unique())
gcolor=st.selectbox("Color",df_cleaned["Gemstone Color"].unique())
gorigin=st.text_input("Origin","Burma")
gcert=st.selectbox("Certification",df_cleaned["Certification"].dropna().unique())
gweight=st.number_input("Weight",3.1)
gprice=st.number_input("Price",2800.0)
topn=st.slider("Top N Buyers",1,30,10)

if st.button("Predict"):
    rows=[]
    for _,c in cust_df.iterrows():
        rows.append({**c,
            "Type":gtype,"Color":gcolor,"Origin":gorigin,
            "Cert":gcert,"Weight":gweight,"Price":gprice})
    pred=pd.DataFrame(rows)
    pred["PurchaseProb"]=clf.predict_proba(pred)[:,1]
    st.session_state.buyers=pred.sort_values("PurchaseProb",ascending=False).head(topn)
    st.session_state.idx=0

# ---------- Results + Email ----------
if "buyers" in st.session_state:
    st.dataframe(st.session_state.buyers[["CustomerID","TotalSpend","PrefType","Recency","PurchaseProb"]])
    b=st.session_state.buyers.iloc[st.session_state.idx]
    name=f"Customer {b.CustomerID}"

    subject=f"Special {gtype} Offer for You"
    body=f"Dear {name},\n\nWe have a new {gtype} gemstone you may like."

    if text_generator:
        subject=text_generator(subject,max_new_tokens=30)[0]["generated_text"]
        body=text_generator(body,max_new_tokens=200)[0]["generated_text"]

    st.subheader("âœ‰ï¸ Email (Human-in-the-loop)")
    sender=st.text_input("Your Gmail")
    pwd=st.text_input("App Password",type="password")
    subject=st.text_input("Subject",subject)
    body=st.text_area("Body",body,200)

    if st.button("Send Email"):
        st.info(send_email(sender,pwd,b.Email if "Email" in b else "",subject,body))
    if st.button("Next Buyer"):
        st.session_state.idx=(st.session_state.idx+1)%len(st.session_state.buyers)
        st.experimental_rerun()
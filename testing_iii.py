# -*- coding: utf-8 -*-
"""testing_III.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1r9b5qD4S4WGWbncHoGPlK4AfoRlM-oWR
"""

# ============================================================
# STREAMLIT VERSION â€” PREDICTIVE BUYER SYSTEM (FULL PARITY)
# ============================================================

import streamlit as st
import pandas as pd
import numpy as np
import random
import re
import ssl
import smtplib
from datetime import datetime

from sklearn.model_selection import train_test_split
from sklearn.compose import ColumnTransformer
from sklearn.preprocessing import OneHotEncoder
from sklearn.pipeline import Pipeline
from sklearn.ensemble import RandomForestClassifier
from sklearn.metrics import accuracy_score, classification_report

from transformers import pipeline as hf_pipeline

# ============================================================
# CONFIG
# ============================================================
st.set_page_config(page_title="Gemstone Buyer Prediction", layout="wide")
COMPANY_NAME = "Crystal Gemstone"

# ============================================================
# HELPERS (UNCHANGED LOGIC)
# ============================================================
def is_valid_email(x):
    if pd.isna(x) or x == "Unknown":
        return False
    return re.match(r"^[^@\s]+@[^@\s]+\.[^@\s]+$", str(x)) is not None

def is_valid_phone(x):
    if pd.isna(x) or x == "Unknown":
        return False
    s = re.sub(r"\D", "", str(x))
    return len(s) >= 7 and not (len(set(s)) == 1)

def remove_outliers_iqr(data, col):
    Q1 = data[col].quantile(0.25)
    Q3 = data[col].quantile(0.75)
    IQR = Q3 - Q1
    lower = Q1 - 1.5 * IQR
    upper = Q3 + 1.5 * IQR
    data[col] = np.clip(data[col], lower, upper)
    return data

# ============================================================
# LLM (EMAIL DRAFTING) â€” SAME MODEL, GUARDED
# ============================================================
@st.cache_resource
def load_llm():
    try:
        return hf_pipeline("text-generation", model="distilgpt2", truncation=True)
    except Exception:
        return None

text_generator = load_llm()

# ============================================================
# EMAIL SENDER (UNCHANGED)
# ============================================================
def send_email(sender_email, sender_password, recipient_email, subject, body):
    try:
        context = ssl.create_default_context()
        with smtplib.SMTP_SSL("smtp.gmail.com", 465, context=context) as server:
            server.login(sender_email, sender_password)
            msg = f"Subject: {subject}\n\n{body}"
            server.sendmail(sender_email, recipient_email, msg.encode("utf-8"))
        return "Email sent successfully."
    except Exception as e:
        return f"Email failed: {e}"

# ============================================================
# STREAMLIT UI â€” DATA LOAD
# ============================================================
st.title("ðŸ’Ž Gemstone Buyer Prediction & Email Utility")

uploaded_file = st.file_uploader("Upload gemstone buyers Excel file", type=["xlsx"])

if not uploaded_file:
    st.info("Please upload the dataset to continue.")
    st.stop()

# ============================================================
# STEP 1â€“3: LOAD & CLEAN DATA (UNCHANGED LOGIC)
# ============================================================
df = pd.read_excel(uploaded_file)

for col in df.select_dtypes(include="object").columns:
    df[col] = df[col].astype(str).str.strip().replace({"": np.nan, "nan": np.nan})

df = df.dropna(subset=["CustomerID", "Gemstone Type", "DateOfPurchase"])

fill_cols = ["Country", "Adress", "Phone No.", "Email",
             "Gemstone Color", "Gemstone Origin", "Certification"]

for c in fill_cols:
    if c in df.columns:
        df[c] = df[c].fillna("Unknown")

if "Email" in df.columns:
    df.loc[~df["Email"].apply(is_valid_email), "Email"] = np.nan

if "Phone No." in df.columns:
    df.loc[~df["Phone No."].apply(is_valid_phone), "Phone No."] = np.nan

df["DateOfPurchase"] = pd.to_datetime(df["DateOfPurchase"], errors="coerce")
df = df[df["DateOfPurchase"] <= pd.to_datetime(datetime.today())]
df = df.dropna(subset=["DateOfPurchase"])

for col in ["Price", "Weight"]:
    if col in df.columns:
        df = remove_outliers_iqr(df, col)

df = df.drop_duplicates()
df_cleaned = df.copy()

# ============================================================
# STEP 5: CUSTOMER FEATURES (RFM + PREFS)
# ============================================================
freq = df_cleaned.groupby("CustomerID").size().rename("Frequency")
monetary = df_cleaned.groupby("CustomerID")["Price"].sum().rename("TotalSpend")
avg_price = df_cleaned.groupby("CustomerID")["Price"].mean().rename("AvgPrice")
avg_weight = df_cleaned.groupby("CustomerID")["Weight"].mean().rename("AvgWeight")
recency = (df_cleaned["DateOfPurchase"].max()
           - df_cleaned.groupby("CustomerID")["DateOfPurchase"].max()).dt.days.rename("Recency")

def mode_or_unknown(s):
    return s.mode().iloc[0] if not s.mode().empty else "Unknown"

pref_type = df_cleaned.groupby("CustomerID")["Gemstone Type"].apply(mode_or_unknown).rename("PrefType")
pref_color = df_cleaned.groupby("CustomerID")["Gemstone Color"].apply(mode_or_unknown).rename("PrefColor")
pref_origin = df_cleaned.groupby("CustomerID")["Gemstone Origin"].apply(mode_or_unknown).rename("PrefOrigin")
pref_cert = df_cleaned.groupby("CustomerID")["Certification"].apply(mode_or_unknown).rename("PrefCert")

customer_df = pd.concat([
    freq, monetary, avg_price, avg_weight,
    recency, pref_type, pref_color, pref_origin, pref_cert
], axis=1).reset_index()

# ============================================================
# STEP 6â€“9: TRAINING PIPELINE (UNCHANGED)
# ============================================================
items = df_cleaned[[
    "Gemstone Type", "Gemstone Color", "Gemstone Origin",
    "Certification", "Weight", "Price"
]].drop_duplicates().reset_index(drop=True)

items["ItemID"] = items.index + 1

rows = []
for cust_id, grp in df_cleaned.groupby("CustomerID"):
    bought = set(tuple(x) for x in grp[
        ["Gemstone Type", "Gemstone Color", "Gemstone Origin", "Certification"]
    ].values)

    for _, r in grp.iterrows():
        rows.append({
            "CustomerID": cust_id,
            "Type": r["Gemstone Type"],
            "Color": r["Gemstone Color"],
            "Origin": r["Gemstone Origin"],
            "Cert": r["Certification"],
            "Weight": r["Weight"],
            "Price": r["Price"],
            "Label": 1
        })

    for _ in range(3):
        it = items.sample(1).iloc[0]
        key = (it["Gemstone Type"], it["Gemstone Color"], it["Gemstone Origin"], it["Certification"])
        if key not in bought:
            rows.append({
                "CustomerID": cust_id,
                "Type": it["Gemstone Type"],
                "Color": it["Gemstone Color"],
                "Origin": it["Gemstone Origin"],
                "Cert": it["Certification"],
                "Weight": it["Weight"],
                "Price": it["Price"],
                "Label": 0
            })

train_df = pd.DataFrame(rows)
train_merged = train_df.merge(customer_df, on="CustomerID", how="left")

X = train_merged.drop(columns=["Label"])
y = train_merged["Label"]

cat_cols = ["Type", "Color", "Origin", "Cert",
            "PrefType", "PrefColor", "PrefOrigin", "PrefCert"]
num_cols = ["Weight", "Price", "Frequency",
            "TotalSpend", "AvgPrice", "AvgWeight", "Recency"]

pre = ColumnTransformer([
    ("cat", OneHotEncoder(handle_unknown="ignore"), cat_cols),
    ("num", "passthrough", num_cols)
])

clf = Pipeline([
    ("preprocess", pre),
    ("model", RandomForestClassifier(n_estimators=200, random_state=42))
])

clf.fit(X, y)

# ============================================================
# STEP 10â€“11: PREDICTION FUNCTION (UNCHANGED)
# ============================================================
contact_info = df_cleaned[[
    "CustomerID", "Adress", "Country", "Email", "Phone No."
]].drop_duplicates("CustomerID")

def predict_top_buyers_ml(new_gem, top_n=10):
    rows = []
    for _, c in customer_df.iterrows():
        rows.append({
            "CustomerID": c["CustomerID"],
            "Type": new_gem["Type"],
            "Color": new_gem["Color"],
            "Origin": new_gem["Origin"],
            "Cert": new_gem["Certification"],
            "Weight": new_gem["Weight"],
            "Price": new_gem["Price"],
            "Frequency": c["Frequency"],
            "TotalSpend": c["TotalSpend"],
            "AvgPrice": c["AvgPrice"],
            "AvgWeight": c["AvgWeight"],
            "Recency": c["Recency"],
            "PrefType": c["PrefType"],
            "PrefColor": c["PrefColor"],
            "PrefOrigin": c["PrefOrigin"],
            "PrefCert": c["PrefCert"]
        })

    dfp = pd.DataFrame(rows)
    dfp["PurchaseProb"] = clf.predict_proba(dfp)[:, 1]
    top = dfp.sort_values("PurchaseProb", ascending=False).head(top_n)
    return top.merge(contact_info, on="CustomerID", how="left")

# ============================================================
# UI â€” PREDICTION + EMAIL (HUMAN-IN-THE-LOOP)
# ============================================================
st.subheader("ðŸ”® Predict Top Buyers")

with st.form("predict"):
    gtype = st.selectbox("Gemstone Type", df_cleaned["Gemstone Type"].unique())
    gcolor = st.selectbox("Gemstone Color", df_cleaned["Gemstone Color"].unique())
    gorigin = st.text_input("Origin", "Burma")
    gcert = st.selectbox("Certification", df_cleaned["Certification"].dropna().unique())
    gweight = st.number_input("Weight (carats)", value=3.1)
    gprice = st.number_input("Price", value=2800.0)
    topn = st.slider("Top N Buyers", 1, 50, 10)
    submitted = st.form_submit_button("Predict")

if submitted:
    st.session_state.buyers = predict_top_buyers_ml({
        "Type": gtype,
        "Color": gcolor,
        "Origin": gorigin,
        "Certification": gcert,
        "Weight": gweight,
        "Price": gprice
    }, topn)
    st.session_state.idx = 0

if "buyers" in st.session_state and not st.session_state.buyers.empty:
    buyers = st.session_state.buyers
    idx = st.session_state.idx
    row = buyers.iloc[idx]

    cust_id = row["CustomerID"]
    customer_name = f"Customer {cust_id}"

    pref_type = customer_df.loc[
        customer_df["CustomerID"] == cust_id, "PrefType"
    ].iloc[0]

    subject = f"Exciting News: A New {gtype} for You!"
    body = f"""Dear {customer_name},

We know you appreciate {pref_type} gemstones.
We are pleased to introduce a new {gtype} gemstone.

Best regards,
{COMPANY_NAME}
"""

    if text_generator is not None:
        try:
            subject = text_generator("Write a gemstone offer email subject", max_new_tokens=30)[0]["generated_text"]
            body = text_generator("Write a gemstone marketing email", max_new_tokens=200)[0]["generated_text"]
        except Exception:
            pass

    st.subheader("âœ‰ï¸ Email Draft")
    sender_email = st.text_input("Your Gmail")
    sender_pass = st.text_input("App Password", type="password")
    email_subject = st.text_input("Subject", subject)
    email_body = st.text_area("Body", body, height=250)

    if st.button("Send Email"):
        st.info(send_email(sender_email, sender_pass, row["Email"], email_subject, email_body))

    if st.button("Next Buyer"):
        st.session_state.idx = (idx + 1) % len(buyers)
        st.experimental_rerun()